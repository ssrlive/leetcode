#![allow(dead_code)]

// 3270. Find the Key of the Numbers
// https://leetcode.com/problems/find-the-key-of-the-numbers/
// https://leetcode.cn/problems/find-the-key-of-the-numbers/
//
// Easy
//
// You are given three positive integers num1, num2, and num3.
//
// The key of num1, num2, and num3 is defined as a four-digit number such that:
//
//     Initially, if any number has less than four digits, it is padded with leading zeros.
//     The ith digit (1 <= i <= 4) of the key is generated by taking the smallest digit among the ith digits of num1, num2, and num3.
//
// Return the key of the three numbers without leading zeros (if any).
//
// Example 1:
//
// Input: num1 = 1, num2 = 10, num3 = 1000
//
// Output: 0
//
// Explanation:
//
// On padding, num1 becomes "0001", num2 becomes "0010", and num3 remains "1000".
//
//     The 1st digit of the key is min(0, 0, 1).
//     The 2nd digit of the key is min(0, 0, 0).
//     The 3rd digit of the key is min(0, 1, 0).
//     The 4th digit of the key is min(1, 0, 0).
//
// Hence, the key is "0000", i.e. 0.
//
// Example 2:
//
// Input: num1 = 987, num2 = 879, num3 = 798
//
// Output: 777
//
// Example 3:
//
// Input: num1 = 1, num2 = 2, num3 = 3
//
// Output: 1
//
// Constraints:
//
//     1 <= num1, num2, num3 <= 9999
//

struct Solution;

impl Solution {
    pub fn generate_key(num1: i32, num2: i32, num3: i32) -> i32 {
        fn f(mut x: i32) -> Vec<i32> {
            let mut r = Vec::with_capacity(4);
            for _ in 0..4 {
                r.push(x % 10);
                x /= 10;
            }
            r
        }

        let xs = [f(num1), f(num2), f(num3)];
        (0..4)
            .map(|i| xs.iter().map(|x| x[3 - i]).min().unwrap())
            .fold(0, |a, x| 10 * a + x)
    }
}

#[test]
fn test() {
    assert_eq!(Solution::generate_key(1, 10, 1000), 0);
    assert_eq!(Solution::generate_key(987, 879, 798), 777);
    assert_eq!(Solution::generate_key(1, 2, 3), 1);
}
