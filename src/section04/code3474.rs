#![allow(dead_code)]

// 3474. Lexicographically Smallest Generated String
// https://leetcode.com/problems/lexicographically-smallest-generated-string/
// https://leetcode.cn/problems/lexicographically-smallest-generated-string/
//
// Hard
//
// You are given two strings, str1 and str2, of lengths n and m, respectively.
//
// A string word of length n + m - 1 is defined to be generated by str1 and str2 if it satisfies
// the following conditions for each index 0 <= i <= n - 1:
//
// - If str1[i] == 'T', the substring of word with size m starting at index i is equal to str2, i.e., word[i..(i + m - 1)] == str2.
// - If str1[i] == 'F', the substring of word with size m starting at index i is not equal to str2, i.e., word[i..(i + m - 1)] != str2.
// - Return the lexicographically smallest possible string that can be generated by str1 and str2.
//   If no string can be generated, return an empty string "".
//
// Example 1:
//
// Input: str1 = "TFTF", str2 = "ab"
//
// Output: "ababa"
//
// Explanation:
//
// The table below represents the string "ababa"
// Index	T/F	Substring of length m
// 0	'T'	"ab"
// 1	'F'	"ba"
// 2	'T'	"ab"
// 3	'F'	"ba"
// The strings "ababa" and "ababb" can be generated by str1 and str2.
//
// Return "ababa" since it is the lexicographically smaller string.
//
// Example 2:
//
// Input: str1 = "TFTF", str2 = "abc"
//
// Output: ""
//
// Explanation:
//
// No string that satisfies the conditions can be generated.
//
// Example 3:
//
// Input: str1 = "F", str2 = "d"
//
// Output: "a"
//
// Constraints:
//
// 1 <= n == str1.length <= 10^4
// 1 <= m == str2.length <= 500
// str1 consists only of 'T' or 'F'.
// str2 consists only of lowercase English characters.
//

struct Solution;

impl Solution {
    pub fn generate_string(str1: String, str2: String) -> String {
        let str1 = str1.as_bytes();
        let str2 = str2.as_bytes();
        let n = str1.len();
        let m = str2.len();
        let mut res = vec!['a'; n + m - 1];
        let mut fixed = vec![false; n + m - 1];
        for i in 0..n {
            if str1[i] == b'T' {
                for j in 0..m {
                    res[i + j] = str2[j] as char;
                    fixed[i + j] = true;
                }
            }
        }
        for i in 0..n {
            if str1[i] == b'F' {
                let mut same = true;
                for j in 0..m {
                    if res[i + j] != str2[j] as char {
                        same = false;
                        break;
                    }
                }
                if same {
                    for j in (0..m).rev() {
                        if !fixed[i + j] {
                            res[i + j] = 'b';
                            break;
                        }
                    }
                }
            }
        }
        for i in 0..n {
            let mut same = true;
            for j in 0..m {
                if res[i + j] != str2[j] as char {
                    same = false;
                    break;
                }
            }
            if (str1[i] == b'T' && !same) || (str1[i] == b'F' && same) {
                return "".to_string();
            }
        }
        res.iter().collect()
    }
}

#[test]
fn test() {
    let str1 = "TFTF".to_string();
    let str2 = "ab".to_string();
    let res = "ababa".to_string();
    assert_eq!(Solution::generate_string(str1, str2), res);

    let str1 = "TFTF".to_string();
    let str2 = "abc".to_string();
    let res = "".to_string();
    assert_eq!(Solution::generate_string(str1, str2), res);

    let str1 = "F".to_string();
    let str2 = "d".to_string();
    let res = "a".to_string();
    assert_eq!(Solution::generate_string(str1, str2), res);
}
